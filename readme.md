### Este repositório é o espaço onde desenvolvo códigos na linguagem C. Optei por essa linguagem devido à sua complexidade e à liberdade que ela oferece. Utilizo a linguagem C para aprofundar meus estudos no kernel do Linux e para escrever artigos sobre otimização e a filosofia da codificação desde 2014.

### Sinta-se à vontade para explorar e examinar os códigos em cada pasta. Neles, você encontrará reflexões internas sobre decisões e pensamentos relacionados a algoritmos e estruturas de dados. Portanto, espere não apenas códigos complexos, mas também uma abordagem que incorpora uma pitada de filosofia e pensamento.


    Arrays:
        Coleção de elementos do mesmo tipo, acessados por índices.

    Listas Ligadas (Linked Lists):
        Elementos ligados por ponteiros, onde cada elemento aponta para o próximo na sequência.

    Pilhas (Stacks):
        Coleção de elementos com operações de inserção (push) e remoção (pop) restritas a um extremo.

    Filas (Queues):
        Coleção de elementos com operações de inserção (enqueue) em um extremo e remoção (dequeue) no outro extremo.

    Árvores:
        Estrutura hierárquica composta por nós, onde cada nó tem zero ou mais nós filhos.

    Árvores Binárias:
        Árvores onde cada nó tem, no máximo, dois filhos.

    Árvores de Busca Binária:
        Árvores binárias onde a chave em cada nó é maior que as chaves em todos os nós da subárvore à esquerda e menor que as chaves em todos os nós da subárvore à direita.

    Grafos:
        Conjunto de vértices e arestas que conectam esses vértices.

    Tabelas de Hash:
        Estrutura que mapeia chaves para valores, permitindo acesso rápido aos valores associados a uma chave.

    Tabelas de Hash com Colisões Resolvidas por Encadeamento:
        Cada posição da tabela de hash contém uma lista encadeada de elementos.

    Tabelas de Hash com Colisões Resolvidas por Endereçamento Aberto:
        Outra abordagem para lidar com colisões, onde a tabela de hash é tratada como um array e, em caso de colisão, a busca continua em posições adjacentes.

    Heaps:
        Estrutura de dados de árvore usada para manter o maior (heap máximo) ou menor (heap mínimo) elemento em sua raiz.

    Fila de Prioridade:
        Estrutura de dados que mantém uma coleção de elementos, cada um associado a uma prioridade.

    Grafos Direcionados e Não Direcionados:
        Grafos onde as arestas têm ou não uma direção.

    Grafos Ponderados:
        Grafos onde as arestas têm pesos associados.

    Matriz:
        Estrutura bidimensional onde os elementos são organizados em linhas e colunas.

    Strings:
        Sequências de caracteres.

    Fila Circular:
        Variação de fila onde o último elemento está ligado ao primeiro.

    Deque (Double-Ended Queue):
        Estrutura que permite operações de inserção e remoção em ambos os extremos.

    Trie:
        Árvore especializada para armazenar um conjunto dinâmico ou associativo onde as chaves geralmente são strings.

    Ordenação:
        Bubble Sort
        Insertion Sort
        Selection Sort
        Merge Sort
        QuickSort
        Heap Sort
        Radix Sort

    Busca:
        Busca Linear
        Busca Binária
        Busca em Árvore Binária de Busca (Binary Search Tree - BST)
        Busca Hash

    Grafos:
        Busca em Largura (Breadth-First Search - BFS)
        Busca em Profundidade (Depth-First Search - DFS)
        Algoritmo de Dijkstra (Caminho Mínimo)
        Algoritmo de Bellman-Ford (Caminho Mínimo com Pesos Negativos)
        Algoritmo de Kruskal (Árvore Geradora Mínima)
        Algoritmo de Prim (Árvore Geradora Mínima)
        Algoritmo de Ford-Fulkerson (Fluxo Máximo)

    Strings:
        Busca em Substring (Substring Search)
        Algoritmo de KMP (Knuth-Morris-Pratt)
        Algoritmo de Boyer-Moore
        Algoritmo de Rabin-Karp

    Divisão e Conquista:
        Merge Sort
        QuickSort
        Strassen (Multiplicação de Matrizes)

    Programação Dinâmica:
        Problema da Mochila (Knapsack Problem)
        Algoritmo de Floyd-Warshall (Caminhos Mínimos em Grafos Ponderados)
        Algoritmo de Dijkstra (Caminho Mínimo)
        Algoritmo de Bellman-Ford (Caminho Mínimo com Pesos Negativos)

    Backtracking:
        N-Rainhas
        Problema do Cavalo no Xadrez
        Labirinto (Rat in a Maze)

    Geometria Computacional:
        Algoritmo de Graham (Envelope Convexo)
        Verificação de Interseção de Linhas e Segmentos de Linhas

    Algoritmos Aleatórios:
        Algoritmo de Las Vegas
        Algoritmo de Monte Carlo

    Algoritmos de Aprendizado de Máquina:
        K-Means
        Árvores de Decisão
        Regressão Linear
        Redes Neurais
        Algoritmos de Agrupamento Hierárquico